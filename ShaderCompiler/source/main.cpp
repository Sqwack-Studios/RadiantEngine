//  Filename: main 
//	Author:	Daniel														
//	Date: 03/07/2025 19:39:51		
//  Sqwack-Studios													

#define WIN32_LEAN_AND_MEAN
#define NOMINMAX

#include <wrl/client.h>
#include "dxc/dxcapi.h"

#undef WIN32_LEAN_AND_MEAN
#undef NOMINMAX

#include <cstdint>
#include <fstream>

#include "quill/Frontend.h"
#include "quill/Backend.h"
#include "quill/LogMacros.h"
#include "quill/sinks/ConsoleSink.h"

using namespace Microsoft::WRL;

//TODO: HRESULTS + logging
//TODO: D3D12 Calls + logging 


int main(int argc, char* argv[])
{

	quill::Backend::start();
	quill::Logger* logger = quill::Frontend::create_or_get_logger(
		"root", quill::Frontend::create_or_get_sink<quill::ConsoleSink>("sink_id_1"));

	LOG_INFO(logger, "Hello from {}!", "Quill");
	
	HINSTANCE dxcLibModule{ LoadLibrary(L"../../../vendor/dxc/bin/dxcompiler.dll") };

	if (!dxcLibModule)
	{
		LOG_CRITICAL(logger, "dxcompiler.dll couldn't be loaded");
		return 0;
	}

	DxcCreateInstanceProc DxcCreateInstance{ (DxcCreateInstanceProc)GetProcAddress(dxcLibModule, "DxcCreateInstance") };

	ComPtr<IDxcCompiler3> dxCompiler;
	DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&dxCompiler));
	
	std::ifstream file{ "../../../assets/shaders/basic.hlsl",std::ios::binary | std::ios::ate | std::ios::in };
	static char shaderBlob[81920]; //4KB
	if (!file.is_open())
	{
		LOG_CRITICAL(logger, "File ../../../assets/shaders/basic.hlsl couldn't be opened");
		return 0;
	}
	std::uint32_t size{ static_cast<std::uint32_t>(file.tellg()) };

	file.seekg(0, std::ios::beg);
	file.read(shaderBlob, size);
	file.close();

	const DxcBuffer dxcBuff{
		.Ptr = shaderBlob,
		.Size = size,
		.Encoding = DXC_CP_ACP
	};

	
	/*
	L"basic.hlsl",							    // Optional shader source file name for error reporting and for PIX shader source view.
	L"-E", L"MainVS",							// Entry point.
	L"-T", L"vs_6_6",							// Target. vs, ps, ds, hs, gs, cs, ms, lib; 6_0 - 6_7
	//L"-Zs",									// Enable debug information (slim format)
	L"-Zi",
	L"-Zpc",									//Pack matrices in column - major order.
	L"-Zpr",									//Pack matrices in row - major order.
	L"-Od",
	//L"-D", L"MYDEFINE=1",						// A single define...
	L"-Fo", L"../../bin/shaders/basic.bin",     // Optional. Stored in the pdb.
	L"-Fd", L"../../bin/shaders/basic.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
	L"-Qstrip_debug",
	L"-Qstrip_priv",
	L"-Qstrip_reflect",							// Strip reflection into a separate blob.
	L"-Qstrip_rootsignature"

	*/
	LPCWSTR pszArgs[] =
	{
		//L"basic.hlsl",							    // Optional shader source file name for error reporting and for PIX shader source view.  
		L"-E", L"VSMain",							// Entry point.
		L"-T", L"vs_6_7",							// Target.
		//L"-Zs",									// Enable debug information (slim format)
		//L"-Zi",
		//L"-Zpc",									//Pack matrices in column - major order.
		//L"-Zpr",									//Pack matrices in row - major order.
		//L"-Od",
		//L"-D", L"MYDEFINE=1",						// A single define...
		L"-Fo", L"../../../bin/basic.bin",     // Optional. Stored in the pdb. 
		//L"-Fd", L"../../../bin/basic.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
		L"-Qstrip_debug",
		L"-Qstrip_priv",
		L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
		L"-Qstrip_rootsignature"
	};
	ComPtr<IDxcResult> compileResult;

	dxCompiler->Compile(&dxcBuff, pszArgs, _countof(pszArgs), nullptr, IID_PPV_ARGS(&compileResult));

	HRESULT hrStatus;
	


	ComPtr<IDxcBlob> pShader = nullptr;
	ComPtr<IDxcBlobUtf16> pShaderName = nullptr;
	compileResult->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&pShader), &pShaderName);

	ComPtr<IDxcBlobUtf8> pErrors = nullptr;
	compileResult->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);

	auto webo{ pErrors->GetStringPointer() };
	auto webo2{ pShaderName->GetStringPointer() };
	// Note that d3dcompiler would return null if no errors or warnings are present.
	// IDxcCompiler3::Compile will always return an error buffer, but its length
	// will be zero if there are no warnings or errors.
	if (pErrors != nullptr && pErrors->GetStringLength() != 0)
		LOG_INFO(logger, "Compiling errors: {}", webo);


	compileResult->GetStatus(&hrStatus);
	if (FAILED(hrStatus))
	{
		LOG_CRITICAL(logger, "Compilation Failed\n");
		return 0;
	}
	
	if (pShader != nullptr)
	{
		FILE* fp = NULL;
	
		_wfopen_s(&fp, pShaderName->GetStringPointer(), L"wb");
		fwrite(pShader->GetBufferPointer(), pShader->GetBufferSize(), 1, fp);
		fclose(fp);
	
	}


	return 0;
}

